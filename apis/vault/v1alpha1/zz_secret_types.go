/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type ReplicationConfigInitParameters struct {
	IsWriteForwardEnabled *bool `json:"isWriteForwardEnabled,omitempty" tf:"is_write_forward_enabled,omitempty"`

	ReplicationTargets []ReplicationTargetsInitParameters `json:"replicationTargets,omitempty" tf:"replication_targets,omitempty"`
}

type ReplicationConfigObservation struct {
	IsWriteForwardEnabled *bool `json:"isWriteForwardEnabled,omitempty" tf:"is_write_forward_enabled,omitempty"`

	ReplicationTargets []ReplicationTargetsObservation `json:"replicationTargets,omitempty" tf:"replication_targets,omitempty"`
}

type ReplicationConfigParameters struct {

	// +kubebuilder:validation:Optional
	IsWriteForwardEnabled *bool `json:"isWriteForwardEnabled,omitempty" tf:"is_write_forward_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	ReplicationTargets []ReplicationTargetsParameters `json:"replicationTargets" tf:"replication_targets,omitempty"`
}

type ReplicationTargetsInitParameters struct {

	// The OCID of the master encryption key that is used to encrypt the secret. You must specify a symmetric key to encrypt the secret during import to the vault. You cannot encrypt secrets with asymmetric keys. Furthermore, the key must exist in the vault that you specify.
	TargetKeyID *string `json:"targetKeyId,omitempty" tf:"target_key_id,omitempty"`

	TargetRegion *string `json:"targetRegion,omitempty" tf:"target_region,omitempty"`

	// The OCID of the vault where you want to create the secret.
	TargetVaultID *string `json:"targetVaultId,omitempty" tf:"target_vault_id,omitempty"`
}

type ReplicationTargetsObservation struct {

	// The OCID of the master encryption key that is used to encrypt the secret. You must specify a symmetric key to encrypt the secret during import to the vault. You cannot encrypt secrets with asymmetric keys. Furthermore, the key must exist in the vault that you specify.
	TargetKeyID *string `json:"targetKeyId,omitempty" tf:"target_key_id,omitempty"`

	TargetRegion *string `json:"targetRegion,omitempty" tf:"target_region,omitempty"`

	// The OCID of the vault where you want to create the secret.
	TargetVaultID *string `json:"targetVaultId,omitempty" tf:"target_vault_id,omitempty"`
}

type ReplicationTargetsParameters struct {

	// The OCID of the master encryption key that is used to encrypt the secret. You must specify a symmetric key to encrypt the secret during import to the vault. You cannot encrypt secrets with asymmetric keys. Furthermore, the key must exist in the vault that you specify.
	// +kubebuilder:validation:Optional
	TargetKeyID *string `json:"targetKeyId" tf:"target_key_id,omitempty"`

	// +kubebuilder:validation:Optional
	TargetRegion *string `json:"targetRegion" tf:"target_region,omitempty"`

	// The OCID of the vault where you want to create the secret.
	// +kubebuilder:validation:Optional
	TargetVaultID *string `json:"targetVaultId" tf:"target_vault_id,omitempty"`
}

type RotationConfigInitParameters struct {

	// (Updatable) Enables auto rotation, when set to true rotationInterval must be set.
	IsScheduledRotationEnabled *bool `json:"isScheduledRotationEnabled,omitempty" tf:"is_scheduled_rotation_enabled,omitempty"`

	// (Updatable) The time interval that indicates the frequency for rotating secret data, as described in ISO 8601 format. The minimum value is 1 day and maximum value is 360 days. For example, if you want to set the time interval for rotating a secret data as 30 days, the duration is expressed as "P30D."
	RotationInterval *string `json:"rotationInterval,omitempty" tf:"rotation_interval,omitempty"`

	// (Updatable) The TargetSystemDetails provides the targetSystem type and type-specific connection metadata
	TargetSystemDetails []TargetSystemDetailsInitParameters `json:"targetSystemDetails,omitempty" tf:"target_system_details,omitempty"`
}

type RotationConfigObservation struct {

	// (Updatable) Enables auto rotation, when set to true rotationInterval must be set.
	IsScheduledRotationEnabled *bool `json:"isScheduledRotationEnabled,omitempty" tf:"is_scheduled_rotation_enabled,omitempty"`

	// (Updatable) The time interval that indicates the frequency for rotating secret data, as described in ISO 8601 format. The minimum value is 1 day and maximum value is 360 days. For example, if you want to set the time interval for rotating a secret data as 30 days, the duration is expressed as "P30D."
	RotationInterval *string `json:"rotationInterval,omitempty" tf:"rotation_interval,omitempty"`

	// (Updatable) The TargetSystemDetails provides the targetSystem type and type-specific connection metadata
	TargetSystemDetails []TargetSystemDetailsObservation `json:"targetSystemDetails,omitempty" tf:"target_system_details,omitempty"`
}

type RotationConfigParameters struct {

	// (Updatable) Enables auto rotation, when set to true rotationInterval must be set.
	// +kubebuilder:validation:Optional
	IsScheduledRotationEnabled *bool `json:"isScheduledRotationEnabled,omitempty" tf:"is_scheduled_rotation_enabled,omitempty"`

	// (Updatable) The time interval that indicates the frequency for rotating secret data, as described in ISO 8601 format. The minimum value is 1 day and maximum value is 360 days. For example, if you want to set the time interval for rotating a secret data as 30 days, the duration is expressed as "P30D."
	// +kubebuilder:validation:Optional
	RotationInterval *string `json:"rotationInterval,omitempty" tf:"rotation_interval,omitempty"`

	// (Updatable) The TargetSystemDetails provides the targetSystem type and type-specific connection metadata
	// +kubebuilder:validation:Optional
	TargetSystemDetails []TargetSystemDetailsParameters `json:"targetSystemDetails" tf:"target_system_details,omitempty"`
}

type SecretContentInitParameters struct {

	// (Updatable) The base64-encoded content of the secret.
	Content *string `json:"content,omitempty" tf:"content,omitempty"`

	// (Updatable) The base64-encoded content of the secret.
	ContentType *string `json:"contentType,omitempty" tf:"content_type,omitempty"`

	// (Updatable) Names should be unique within a secret. Valid characters are uppercase or lowercase letters, numbers, hyphens, underscores, and periods.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (Updatable) The rotation state of the secret content. The default is CURRENT, meaning that the secret is currently in use. A secret version that you mark as PENDING is staged and available for use, but you don't yet want to rotate it into current, active use. For example, you might create or update a secret and mark its rotation state as PENDING if you haven't yet updated the secret on the target system. When creating a secret, only the value CURRENT is applicable, although the value LATEST is also automatically applied. When updating a secret, you can specify a version's rotation state as either CURRENT or PENDING.
	Stage *string `json:"stage,omitempty" tf:"stage,omitempty"`
}

type SecretContentObservation struct {

	// (Updatable) The base64-encoded content of the secret.
	Content *string `json:"content,omitempty" tf:"content,omitempty"`

	// (Updatable) The base64-encoded content of the secret.
	ContentType *string `json:"contentType,omitempty" tf:"content_type,omitempty"`

	// (Updatable) Names should be unique within a secret. Valid characters are uppercase or lowercase letters, numbers, hyphens, underscores, and periods.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (Updatable) The rotation state of the secret content. The default is CURRENT, meaning that the secret is currently in use. A secret version that you mark as PENDING is staged and available for use, but you don't yet want to rotate it into current, active use. For example, you might create or update a secret and mark its rotation state as PENDING if you haven't yet updated the secret on the target system. When creating a secret, only the value CURRENT is applicable, although the value LATEST is also automatically applied. When updating a secret, you can specify a version's rotation state as either CURRENT or PENDING.
	Stage *string `json:"stage,omitempty" tf:"stage,omitempty"`
}

type SecretContentParameters struct {

	// (Updatable) The base64-encoded content of the secret.
	// +kubebuilder:validation:Optional
	Content *string `json:"content,omitempty" tf:"content,omitempty"`

	// (Updatable) The base64-encoded content of the secret.
	// +kubebuilder:validation:Optional
	ContentType *string `json:"contentType" tf:"content_type,omitempty"`

	// (Updatable) Names should be unique within a secret. Valid characters are uppercase or lowercase letters, numbers, hyphens, underscores, and periods.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (Updatable) The rotation state of the secret content. The default is CURRENT, meaning that the secret is currently in use. A secret version that you mark as PENDING is staged and available for use, but you don't yet want to rotate it into current, active use. For example, you might create or update a secret and mark its rotation state as PENDING if you haven't yet updated the secret on the target system. When creating a secret, only the value CURRENT is applicable, although the value LATEST is also automatically applied. When updating a secret, you can specify a version's rotation state as either CURRENT or PENDING.
	// +kubebuilder:validation:Optional
	Stage *string `json:"stage,omitempty" tf:"stage,omitempty"`
}

type SecretGenerationContextInitParameters struct {

	// (Updatable) Name of random bytes generation template for generating random byte type secret.
	GenerationTemplate *string `json:"generationTemplate,omitempty" tf:"generation_template,omitempty"`

	// (Updatable) Name of the predefined secret generation type.
	GenerationType *string `json:"generationType,omitempty" tf:"generation_type,omitempty"`

	// (Applicable when generation_type=PASSPHRASE) (Updatable) Length of the passphrase to be generated
	PassphraseLength *float64 `json:"passphraseLength,omitempty" tf:"passphrase_length,omitempty"`

	// (Updatable) SecretTemplate captures structure in which customer wants to store secrets. This is optional and a default structure is available for each secret type.  The template can have any structure with static values that are not generated. Within the template, you can insert predefined placeholders to store secrets.  These placeholders are later replaced with the generated content and saved as a Base64 encoded content.
	SecretTemplate *string `json:"secretTemplate,omitempty" tf:"secret_template,omitempty"`
}

type SecretGenerationContextObservation struct {

	// (Updatable) Name of random bytes generation template for generating random byte type secret.
	GenerationTemplate *string `json:"generationTemplate,omitempty" tf:"generation_template,omitempty"`

	// (Updatable) Name of the predefined secret generation type.
	GenerationType *string `json:"generationType,omitempty" tf:"generation_type,omitempty"`

	// (Applicable when generation_type=PASSPHRASE) (Updatable) Length of the passphrase to be generated
	PassphraseLength *float64 `json:"passphraseLength,omitempty" tf:"passphrase_length,omitempty"`

	// (Updatable) SecretTemplate captures structure in which customer wants to store secrets. This is optional and a default structure is available for each secret type.  The template can have any structure with static values that are not generated. Within the template, you can insert predefined placeholders to store secrets.  These placeholders are later replaced with the generated content and saved as a Base64 encoded content.
	SecretTemplate *string `json:"secretTemplate,omitempty" tf:"secret_template,omitempty"`
}

type SecretGenerationContextParameters struct {

	// (Updatable) Name of random bytes generation template for generating random byte type secret.
	// +kubebuilder:validation:Optional
	GenerationTemplate *string `json:"generationTemplate" tf:"generation_template,omitempty"`

	// (Updatable) Name of the predefined secret generation type.
	// +kubebuilder:validation:Optional
	GenerationType *string `json:"generationType" tf:"generation_type,omitempty"`

	// (Applicable when generation_type=PASSPHRASE) (Updatable) Length of the passphrase to be generated
	// +kubebuilder:validation:Optional
	PassphraseLength *float64 `json:"passphraseLength,omitempty" tf:"passphrase_length,omitempty"`

	// (Updatable) SecretTemplate captures structure in which customer wants to store secrets. This is optional and a default structure is available for each secret type.  The template can have any structure with static values that are not generated. Within the template, you can insert predefined placeholders to store secrets.  These placeholders are later replaced with the generated content and saved as a Base64 encoded content.
	// +kubebuilder:validation:Optional
	SecretTemplate *string `json:"secretTemplate,omitempty" tf:"secret_template,omitempty"`
}

type SecretInitParameters struct {

	// (Updatable) The OCID of the compartment where you want to create the secret.
	// +crossplane:generate:reference:type=github.com/oracle/provider-oci/apis/identity/v1alpha1.Compartment
	CompartmentID *string `json:"compartmentId,omitempty" tf:"compartment_id,omitempty"`

	// Reference to a Compartment in identity to populate compartmentId.
	// +kubebuilder:validation:Optional
	CompartmentIDRef *v1.Reference `json:"compartmentIdRef,omitempty" tf:"-"`

	// Selector for a Compartment in identity to populate compartmentId.
	// +kubebuilder:validation:Optional
	CompartmentIDSelector *v1.Selector `json:"compartmentIdSelector,omitempty" tf:"-"`

	// (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see Resource Tags. Example: {"Operations.CostCenter": "42"}
	// +mapType=granular
	DefinedTags map[string]*string `json:"definedTags,omitempty" tf:"defined_tags,omitempty"`

	// (Updatable) A brief description of the secret. Avoid entering confidential information.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// (Updatable) The value of this flag determines whether or not secret content will be generated automatically. If not set, it defaults to false.
	EnableAutoGeneration *bool `json:"enableAutoGeneration,omitempty" tf:"enable_auto_generation,omitempty"`

	// (Updatable) Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see Resource Tags. Example: {"Department": "Finance"}
	// +mapType=granular
	FreeformTags map[string]*string `json:"freeformTags,omitempty" tf:"freeform_tags,omitempty"`

	// The OCID of the master encryption key that is used to encrypt the secret. You must specify a symmetric key to encrypt the secret during import to the vault. You cannot encrypt secrets with asymmetric keys. Furthermore, the key must exist in the vault that you specify.
	// +crossplane:generate:reference:type=github.com/oracle/provider-oci/apis/kms/v1alpha1.Key
	KeyID *string `json:"keyId,omitempty" tf:"key_id,omitempty"`

	// Reference to a Key in kms to populate keyId.
	// +kubebuilder:validation:Optional
	KeyIDRef *v1.Reference `json:"keyIdRef,omitempty" tf:"-"`

	// Selector for a Key in kms to populate keyId.
	// +kubebuilder:validation:Optional
	KeyIDSelector *v1.Selector `json:"keyIdSelector,omitempty" tf:"-"`

	// (Updatable) Additional metadata that you can use to provide context about how to use the secret during rotation or other administrative tasks. For example, for a secret that you use to connect to a database, the additional metadata might specify the connection endpoint and the connection string. Provide additional metadata as key-value pairs.
	// +mapType=granular
	Metadata map[string]*string `json:"metadata,omitempty" tf:"metadata,omitempty"`

	ReplicationConfig []ReplicationConfigInitParameters `json:"replicationConfig,omitempty" tf:"replication_config,omitempty"`

	// (Updatable) Defines the frequency of the rotation and the information about the target system
	RotationConfig []RotationConfigInitParameters `json:"rotationConfig,omitempty" tf:"rotation_config,omitempty"`

	// (Updatable) The content of the secret and metadata to help identify it.
	SecretContent []SecretContentInitParameters `json:"secretContent,omitempty" tf:"secret_content,omitempty"`

	// (Updatable) Captures a configurable set of secret generation rules such as length, base characters, additional characters, and so on.
	SecretGenerationContext []SecretGenerationContextInitParameters `json:"secretGenerationContext,omitempty" tf:"secret_generation_context,omitempty"`

	// A user-friendly name for the secret. Secret names should be unique within a vault. Avoid entering confidential information. Valid characters are uppercase or lowercase letters, numbers, hyphens, underscores, and periods.
	SecretName *string `json:"secretName,omitempty" tf:"secret_name,omitempty"`

	// (Updatable) A list of rules to control how the secret is used and managed.
	SecretRules []SecretRulesInitParameters `json:"secretRules,omitempty" tf:"secret_rules,omitempty"`

	// The OCID of the vault where you want to create the secret.
	// +crossplane:generate:reference:type=github.com/oracle/provider-oci/apis/kms/v1alpha1.Vault
	VaultID *string `json:"vaultId,omitempty" tf:"vault_id,omitempty"`

	// Reference to a Vault in kms to populate vaultId.
	// +kubebuilder:validation:Optional
	VaultIDRef *v1.Reference `json:"vaultIdRef,omitempty" tf:"-"`

	// Selector for a Vault in kms to populate vaultId.
	// +kubebuilder:validation:Optional
	VaultIDSelector *v1.Selector `json:"vaultIdSelector,omitempty" tf:"-"`
}

type SecretObservation struct {

	// (Updatable) The OCID of the compartment where you want to create the secret.
	CompartmentID *string `json:"compartmentId,omitempty" tf:"compartment_id,omitempty"`

	// The version number of the secret version that's currently in use.
	CurrentVersionNumber *string `json:"currentVersionNumber,omitempty" tf:"current_version_number,omitempty"`

	// (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see Resource Tags. Example: {"Operations.CostCenter": "42"}
	// +mapType=granular
	DefinedTags map[string]*string `json:"definedTags,omitempty" tf:"defined_tags,omitempty"`

	// (Updatable) A brief description of the secret. Avoid entering confidential information.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// (Updatable) The value of this flag determines whether or not secret content will be generated automatically. If not set, it defaults to false.
	EnableAutoGeneration *bool `json:"enableAutoGeneration,omitempty" tf:"enable_auto_generation,omitempty"`

	// (Updatable) Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see Resource Tags. Example: {"Department": "Finance"}
	// +mapType=granular
	FreeformTags map[string]*string `json:"freeformTags,omitempty" tf:"freeform_tags,omitempty"`

	// The OCID of the secret.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// The value of this flag determines whether or not secret content will be generated automatically.
	IsAutoGenerationEnabled *bool `json:"isAutoGenerationEnabled,omitempty" tf:"is_auto_generation_enabled,omitempty"`

	IsReplica *bool `json:"isReplica,omitempty" tf:"is_replica,omitempty"`

	// The OCID of the master encryption key that is used to encrypt the secret. You must specify a symmetric key to encrypt the secret during import to the vault. You cannot encrypt secrets with asymmetric keys. Furthermore, the key must exist in the vault that you specify.
	KeyID *string `json:"keyId,omitempty" tf:"key_id,omitempty"`

	// A property indicating when the secret was last rotated successfully, expressed in RFC 3339 timestamp format. Example: 2019-04-03T21:10:29.600Z
	LastRotationTime *string `json:"lastRotationTime,omitempty" tf:"last_rotation_time,omitempty"`

	// Additional information about the current lifecycle state of the secret.
	LifecycleDetails *string `json:"lifecycleDetails,omitempty" tf:"lifecycle_details,omitempty"`

	// (Updatable) Additional metadata that you can use to provide context about how to use the secret during rotation or other administrative tasks. For example, for a secret that you use to connect to a database, the additional metadata might specify the connection endpoint and the connection string. Provide additional metadata as key-value pairs.
	// +mapType=granular
	Metadata map[string]*string `json:"metadata,omitempty" tf:"metadata,omitempty"`

	// A property indicating when the secret is scheduled to be rotated, expressed in RFC 3339 timestamp format. Example: 2019-04-03T21:10:29.600Z
	NextRotationTime *string `json:"nextRotationTime,omitempty" tf:"next_rotation_time,omitempty"`

	ReplicationConfig []ReplicationConfigObservation `json:"replicationConfig,omitempty" tf:"replication_config,omitempty"`

	// (Updatable) Defines the frequency of the rotation and the information about the target system
	RotationConfig []RotationConfigObservation `json:"rotationConfig,omitempty" tf:"rotation_config,omitempty"`

	// Additional information about the status of the secret rotation
	RotationStatus *string `json:"rotationStatus,omitempty" tf:"rotation_status,omitempty"`

	// (Updatable) The content of the secret and metadata to help identify it.
	SecretContent []SecretContentObservation `json:"secretContent,omitempty" tf:"secret_content,omitempty"`

	// (Updatable) Captures a configurable set of secret generation rules such as length, base characters, additional characters, and so on.
	SecretGenerationContext []SecretGenerationContextObservation `json:"secretGenerationContext,omitempty" tf:"secret_generation_context,omitempty"`

	// A user-friendly name for the secret. Secret names should be unique within a vault. Avoid entering confidential information. Valid characters are uppercase or lowercase letters, numbers, hyphens, underscores, and periods.
	SecretName *string `json:"secretName,omitempty" tf:"secret_name,omitempty"`

	// (Updatable) A list of rules to control how the secret is used and managed.
	SecretRules []SecretRulesObservation `json:"secretRules,omitempty" tf:"secret_rules,omitempty"`

	SourceRegionInformation []SourceRegionInformationObservation `json:"sourceRegionInformation,omitempty" tf:"source_region_information,omitempty"`

	// The current lifecycle state of the secret.
	State *string `json:"state,omitempty" tf:"state,omitempty"`

	// A property indicating when the secret was created, expressed in RFC 3339 timestamp format. Example: 2019-04-03T21:10:29.600Z
	TimeCreated *string `json:"timeCreated,omitempty" tf:"time_created,omitempty"`

	// An optional property indicating when the current secret version will expire, expressed in RFC 3339 timestamp format. Example: 2019-04-03T21:10:29.600Z
	TimeOfCurrentVersionExpiry *string `json:"timeOfCurrentVersionExpiry,omitempty" tf:"time_of_current_version_expiry,omitempty"`

	// An optional property indicating when to delete the secret, expressed in RFC 3339 timestamp format. Example: 2019-04-03T21:10:29.600Z
	TimeOfDeletion *string `json:"timeOfDeletion,omitempty" tf:"time_of_deletion,omitempty"`

	// The OCID of the vault where you want to create the secret.
	VaultID *string `json:"vaultId,omitempty" tf:"vault_id,omitempty"`
}

type SecretParameters struct {

	// (Updatable) The OCID of the compartment where you want to create the secret.
	// +crossplane:generate:reference:type=github.com/oracle/provider-oci/apis/identity/v1alpha1.Compartment
	// +kubebuilder:validation:Optional
	CompartmentID *string `json:"compartmentId,omitempty" tf:"compartment_id,omitempty"`

	// Reference to a Compartment in identity to populate compartmentId.
	// +kubebuilder:validation:Optional
	CompartmentIDRef *v1.Reference `json:"compartmentIdRef,omitempty" tf:"-"`

	// Selector for a Compartment in identity to populate compartmentId.
	// +kubebuilder:validation:Optional
	CompartmentIDSelector *v1.Selector `json:"compartmentIdSelector,omitempty" tf:"-"`

	// (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see Resource Tags. Example: {"Operations.CostCenter": "42"}
	// +kubebuilder:validation:Optional
	// +mapType=granular
	DefinedTags map[string]*string `json:"definedTags,omitempty" tf:"defined_tags,omitempty"`

	// (Updatable) A brief description of the secret. Avoid entering confidential information.
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// (Updatable) The value of this flag determines whether or not secret content will be generated automatically. If not set, it defaults to false.
	// +kubebuilder:validation:Optional
	EnableAutoGeneration *bool `json:"enableAutoGeneration,omitempty" tf:"enable_auto_generation,omitempty"`

	// (Updatable) Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see Resource Tags. Example: {"Department": "Finance"}
	// +kubebuilder:validation:Optional
	// +mapType=granular
	FreeformTags map[string]*string `json:"freeformTags,omitempty" tf:"freeform_tags,omitempty"`

	// The OCID of the master encryption key that is used to encrypt the secret. You must specify a symmetric key to encrypt the secret during import to the vault. You cannot encrypt secrets with asymmetric keys. Furthermore, the key must exist in the vault that you specify.
	// +crossplane:generate:reference:type=github.com/oracle/provider-oci/apis/kms/v1alpha1.Key
	// +kubebuilder:validation:Optional
	KeyID *string `json:"keyId,omitempty" tf:"key_id,omitempty"`

	// Reference to a Key in kms to populate keyId.
	// +kubebuilder:validation:Optional
	KeyIDRef *v1.Reference `json:"keyIdRef,omitempty" tf:"-"`

	// Selector for a Key in kms to populate keyId.
	// +kubebuilder:validation:Optional
	KeyIDSelector *v1.Selector `json:"keyIdSelector,omitempty" tf:"-"`

	// (Updatable) Additional metadata that you can use to provide context about how to use the secret during rotation or other administrative tasks. For example, for a secret that you use to connect to a database, the additional metadata might specify the connection endpoint and the connection string. Provide additional metadata as key-value pairs.
	// +kubebuilder:validation:Optional
	// +mapType=granular
	Metadata map[string]*string `json:"metadata,omitempty" tf:"metadata,omitempty"`

	// +kubebuilder:validation:Optional
	ReplicationConfig []ReplicationConfigParameters `json:"replicationConfig,omitempty" tf:"replication_config,omitempty"`

	// (Updatable) Defines the frequency of the rotation and the information about the target system
	// +kubebuilder:validation:Optional
	RotationConfig []RotationConfigParameters `json:"rotationConfig,omitempty" tf:"rotation_config,omitempty"`

	// (Updatable) The content of the secret and metadata to help identify it.
	// +kubebuilder:validation:Optional
	SecretContent []SecretContentParameters `json:"secretContent,omitempty" tf:"secret_content,omitempty"`

	// (Updatable) Captures a configurable set of secret generation rules such as length, base characters, additional characters, and so on.
	// +kubebuilder:validation:Optional
	SecretGenerationContext []SecretGenerationContextParameters `json:"secretGenerationContext,omitempty" tf:"secret_generation_context,omitempty"`

	// A user-friendly name for the secret. Secret names should be unique within a vault. Avoid entering confidential information. Valid characters are uppercase or lowercase letters, numbers, hyphens, underscores, and periods.
	// +kubebuilder:validation:Optional
	SecretName *string `json:"secretName,omitempty" tf:"secret_name,omitempty"`

	// (Updatable) A list of rules to control how the secret is used and managed.
	// +kubebuilder:validation:Optional
	SecretRules []SecretRulesParameters `json:"secretRules,omitempty" tf:"secret_rules,omitempty"`

	// The OCID of the vault where you want to create the secret.
	// +crossplane:generate:reference:type=github.com/oracle/provider-oci/apis/kms/v1alpha1.Vault
	// +kubebuilder:validation:Optional
	VaultID *string `json:"vaultId,omitempty" tf:"vault_id,omitempty"`

	// Reference to a Vault in kms to populate vaultId.
	// +kubebuilder:validation:Optional
	VaultIDRef *v1.Reference `json:"vaultIdRef,omitempty" tf:"-"`

	// Selector for a Vault in kms to populate vaultId.
	// +kubebuilder:validation:Optional
	VaultIDSelector *v1.Selector `json:"vaultIdSelector,omitempty" tf:"-"`
}

type SecretRulesInitParameters struct {

	// (Applicable when rule_type=SECRET_REUSE_RULE) (Updatable) A property indicating whether the rule is applied even if the secret version with the content you are trying to reuse was deleted.
	IsEnforcedOnDeletedSecretVersions *bool `json:"isEnforcedOnDeletedSecretVersions,omitempty" tf:"is_enforced_on_deleted_secret_versions,omitempty"`

	// (Applicable when rule_type=SECRET_EXPIRY_RULE) (Updatable) A property indicating whether to block retrieval of the secret content, on expiry. The default is false. If the secret has already expired and you would like to retrieve the secret contents, you need to edit the secret rule to disable this property, to allow reading the secret content.
	IsSecretContentRetrievalBlockedOnExpiry *bool `json:"isSecretContentRetrievalBlockedOnExpiry,omitempty" tf:"is_secret_content_retrieval_blocked_on_expiry,omitempty"`

	// (Updatable) The type of rule, which either controls when the secret contents expire or whether they can be reused.
	RuleType *string `json:"ruleType,omitempty" tf:"rule_type,omitempty"`

	// (Applicable when rule_type=SECRET_EXPIRY_RULE) (Updatable) A property indicating how long the secret contents will be considered valid, expressed in ISO 8601 format. The secret needs to be updated when the secret content expires. The timer resets after you update the secret contents. The minimum value is 1 day and the maximum value is 90 days for this property. Currently, only intervals expressed in days are supported. For example, pass P3D to have the secret version expire every 3 days.
	SecretVersionExpiryInterval *string `json:"secretVersionExpiryInterval,omitempty" tf:"secret_version_expiry_interval,omitempty"`

	// (Applicable when rule_type=SECRET_EXPIRY_RULE) (Updatable) An optional property indicating the absolute time when this secret will expire, expressed in RFC 3339 timestamp format. The minimum number of days from current time is 1 day and the maximum number of days from current time is 365 days. Example: 2019-04-03T21:10:29.600Z
	TimeOfAbsoluteExpiry *string `json:"timeOfAbsoluteExpiry,omitempty" tf:"time_of_absolute_expiry,omitempty"`
}

type SecretRulesObservation struct {

	// (Applicable when rule_type=SECRET_REUSE_RULE) (Updatable) A property indicating whether the rule is applied even if the secret version with the content you are trying to reuse was deleted.
	IsEnforcedOnDeletedSecretVersions *bool `json:"isEnforcedOnDeletedSecretVersions,omitempty" tf:"is_enforced_on_deleted_secret_versions,omitempty"`

	// (Applicable when rule_type=SECRET_EXPIRY_RULE) (Updatable) A property indicating whether to block retrieval of the secret content, on expiry. The default is false. If the secret has already expired and you would like to retrieve the secret contents, you need to edit the secret rule to disable this property, to allow reading the secret content.
	IsSecretContentRetrievalBlockedOnExpiry *bool `json:"isSecretContentRetrievalBlockedOnExpiry,omitempty" tf:"is_secret_content_retrieval_blocked_on_expiry,omitempty"`

	// (Updatable) The type of rule, which either controls when the secret contents expire or whether they can be reused.
	RuleType *string `json:"ruleType,omitempty" tf:"rule_type,omitempty"`

	// (Applicable when rule_type=SECRET_EXPIRY_RULE) (Updatable) A property indicating how long the secret contents will be considered valid, expressed in ISO 8601 format. The secret needs to be updated when the secret content expires. The timer resets after you update the secret contents. The minimum value is 1 day and the maximum value is 90 days for this property. Currently, only intervals expressed in days are supported. For example, pass P3D to have the secret version expire every 3 days.
	SecretVersionExpiryInterval *string `json:"secretVersionExpiryInterval,omitempty" tf:"secret_version_expiry_interval,omitempty"`

	// (Applicable when rule_type=SECRET_EXPIRY_RULE) (Updatable) An optional property indicating the absolute time when this secret will expire, expressed in RFC 3339 timestamp format. The minimum number of days from current time is 1 day and the maximum number of days from current time is 365 days. Example: 2019-04-03T21:10:29.600Z
	TimeOfAbsoluteExpiry *string `json:"timeOfAbsoluteExpiry,omitempty" tf:"time_of_absolute_expiry,omitempty"`
}

type SecretRulesParameters struct {

	// (Applicable when rule_type=SECRET_REUSE_RULE) (Updatable) A property indicating whether the rule is applied even if the secret version with the content you are trying to reuse was deleted.
	// +kubebuilder:validation:Optional
	IsEnforcedOnDeletedSecretVersions *bool `json:"isEnforcedOnDeletedSecretVersions,omitempty" tf:"is_enforced_on_deleted_secret_versions,omitempty"`

	// (Applicable when rule_type=SECRET_EXPIRY_RULE) (Updatable) A property indicating whether to block retrieval of the secret content, on expiry. The default is false. If the secret has already expired and you would like to retrieve the secret contents, you need to edit the secret rule to disable this property, to allow reading the secret content.
	// +kubebuilder:validation:Optional
	IsSecretContentRetrievalBlockedOnExpiry *bool `json:"isSecretContentRetrievalBlockedOnExpiry,omitempty" tf:"is_secret_content_retrieval_blocked_on_expiry,omitempty"`

	// (Updatable) The type of rule, which either controls when the secret contents expire or whether they can be reused.
	// +kubebuilder:validation:Optional
	RuleType *string `json:"ruleType" tf:"rule_type,omitempty"`

	// (Applicable when rule_type=SECRET_EXPIRY_RULE) (Updatable) A property indicating how long the secret contents will be considered valid, expressed in ISO 8601 format. The secret needs to be updated when the secret content expires. The timer resets after you update the secret contents. The minimum value is 1 day and the maximum value is 90 days for this property. Currently, only intervals expressed in days are supported. For example, pass P3D to have the secret version expire every 3 days.
	// +kubebuilder:validation:Optional
	SecretVersionExpiryInterval *string `json:"secretVersionExpiryInterval,omitempty" tf:"secret_version_expiry_interval,omitempty"`

	// (Applicable when rule_type=SECRET_EXPIRY_RULE) (Updatable) An optional property indicating the absolute time when this secret will expire, expressed in RFC 3339 timestamp format. The minimum number of days from current time is 1 day and the maximum number of days from current time is 365 days. Example: 2019-04-03T21:10:29.600Z
	// +kubebuilder:validation:Optional
	TimeOfAbsoluteExpiry *string `json:"timeOfAbsoluteExpiry,omitempty" tf:"time_of_absolute_expiry,omitempty"`
}

type SourceRegionInformationInitParameters struct {
}

type SourceRegionInformationObservation struct {

	// The OCID of the master encryption key that is used to encrypt the secret. You must specify a symmetric key to encrypt the secret during import to the vault. You cannot encrypt secrets with asymmetric keys. Furthermore, the key must exist in the vault that you specify.
	SourceKeyID *string `json:"sourceKeyId,omitempty" tf:"source_key_id,omitempty"`

	SourceRegion *string `json:"sourceRegion,omitempty" tf:"source_region,omitempty"`

	// The OCID of the vault where you want to create the secret.
	SourceVaultID *string `json:"sourceVaultId,omitempty" tf:"source_vault_id,omitempty"`
}

type SourceRegionInformationParameters struct {
}

type TargetSystemDetailsInitParameters struct {

	// (Updatable) The unique identifier (OCID) for the autonomous database that Vault Secret connects to.
	AdbID *string `json:"adbId,omitempty" tf:"adb_id,omitempty"`

	// (Updatable) The unique identifier (OCID) of the Oracle Cloud Infrastructure Functions that vault secret connects to.
	FunctionID *string `json:"functionId,omitempty" tf:"function_id,omitempty"`

	// (Updatable) Unique identifier of the target system that Vault Secret connects to.
	TargetSystemType *string `json:"targetSystemType,omitempty" tf:"target_system_type,omitempty"`
}

type TargetSystemDetailsObservation struct {

	// (Updatable) The unique identifier (OCID) for the autonomous database that Vault Secret connects to.
	AdbID *string `json:"adbId,omitempty" tf:"adb_id,omitempty"`

	// (Updatable) The unique identifier (OCID) of the Oracle Cloud Infrastructure Functions that vault secret connects to.
	FunctionID *string `json:"functionId,omitempty" tf:"function_id,omitempty"`

	// (Updatable) Unique identifier of the target system that Vault Secret connects to.
	TargetSystemType *string `json:"targetSystemType,omitempty" tf:"target_system_type,omitempty"`
}

type TargetSystemDetailsParameters struct {

	// (Updatable) The unique identifier (OCID) for the autonomous database that Vault Secret connects to.
	// +kubebuilder:validation:Optional
	AdbID *string `json:"adbId,omitempty" tf:"adb_id,omitempty"`

	// (Updatable) The unique identifier (OCID) of the Oracle Cloud Infrastructure Functions that vault secret connects to.
	// +kubebuilder:validation:Optional
	FunctionID *string `json:"functionId,omitempty" tf:"function_id,omitempty"`

	// (Updatable) Unique identifier of the target system that Vault Secret connects to.
	// +kubebuilder:validation:Optional
	TargetSystemType *string `json:"targetSystemType" tf:"target_system_type,omitempty"`
}

// SecretSpec defines the desired state of Secret
type SecretSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     SecretParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider SecretInitParameters `json:"initProvider,omitempty"`
}

// SecretStatus defines the observed state of Secret.
type SecretStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        SecretObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// Secret is the Schema for the Secrets API. Provides the Secret resource in Oracle Cloud Infrastructure Vault service
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,oci}
type Secret struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.secretName) || (has(self.initProvider) && has(self.initProvider.secretName))",message="spec.forProvider.secretName is a required parameter"
	Spec   SecretSpec   `json:"spec"`
	Status SecretStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// SecretList contains a list of Secrets
type SecretList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Secret `json:"items"`
}

// Repository type metadata.
var (
	Secret_Kind             = "Secret"
	Secret_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Secret_Kind}.String()
	Secret_KindAPIVersion   = Secret_Kind + "." + CRDGroupVersion.String()
	Secret_GroupVersionKind = CRDGroupVersion.WithKind(Secret_Kind)
)

func init() {
	SchemeBuilder.Register(&Secret{}, &SecretList{})
}
