/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type KerberosInitParameters struct {

	// (Updatable) Version of the keytab Secret in the Vault to use as a backup.
	BackupKeyTabSecretVersion *float64 `json:"backupKeyTabSecretVersion,omitempty" tf:"backup_key_tab_secret_version,omitempty"`

	// (Updatable) Version of the keytab Secret in the Vault to use.
	CurrentKeyTabSecretVersion *float64 `json:"currentKeyTabSecretVersion,omitempty" tf:"current_key_tab_secret_version,omitempty"`

	// (Updatable) Specifies whether to enable or disable Kerberos.
	IsKerberosEnabled *bool `json:"isKerberosEnabled,omitempty" tf:"is_kerberos_enabled,omitempty"`

	// (Updatable) The Kerberos realm that the mount target will join.
	KerberosRealm *string `json:"kerberosRealm,omitempty" tf:"kerberos_realm,omitempty"`

	// (Updatable) The OCID of the keytab Secret in the Vault.
	KeyTabSecretID *string `json:"keyTabSecretId,omitempty" tf:"key_tab_secret_id,omitempty"`
}

type KerberosObservation struct {

	// (Updatable) Version of the keytab Secret in the Vault to use as a backup.
	BackupKeyTabSecretVersion *float64 `json:"backupKeyTabSecretVersion,omitempty" tf:"backup_key_tab_secret_version,omitempty"`

	// (Updatable) Version of the keytab Secret in the Vault to use.
	CurrentKeyTabSecretVersion *float64 `json:"currentKeyTabSecretVersion,omitempty" tf:"current_key_tab_secret_version,omitempty"`

	// (Updatable) Specifies whether to enable or disable Kerberos.
	IsKerberosEnabled *bool `json:"isKerberosEnabled,omitempty" tf:"is_kerberos_enabled,omitempty"`

	// (Updatable) The Kerberos realm that the mount target will join.
	KerberosRealm *string `json:"kerberosRealm,omitempty" tf:"kerberos_realm,omitempty"`

	// (Updatable) The OCID of the keytab Secret in the Vault.
	KeyTabSecretID *string `json:"keyTabSecretId,omitempty" tf:"key_tab_secret_id,omitempty"`
}

type KerberosParameters struct {

	// (Updatable) Version of the keytab Secret in the Vault to use as a backup.
	// +kubebuilder:validation:Optional
	BackupKeyTabSecretVersion *float64 `json:"backupKeyTabSecretVersion,omitempty" tf:"backup_key_tab_secret_version,omitempty"`

	// (Updatable) Version of the keytab Secret in the Vault to use.
	// +kubebuilder:validation:Optional
	CurrentKeyTabSecretVersion *float64 `json:"currentKeyTabSecretVersion,omitempty" tf:"current_key_tab_secret_version,omitempty"`

	// (Updatable) Specifies whether to enable or disable Kerberos.
	// +kubebuilder:validation:Optional
	IsKerberosEnabled *bool `json:"isKerberosEnabled,omitempty" tf:"is_kerberos_enabled,omitempty"`

	// (Updatable) The Kerberos realm that the mount target will join.
	// +kubebuilder:validation:Optional
	KerberosRealm *string `json:"kerberosRealm" tf:"kerberos_realm,omitempty"`

	// (Updatable) The OCID of the keytab Secret in the Vault.
	// +kubebuilder:validation:Optional
	KeyTabSecretID *string `json:"keyTabSecretId,omitempty" tf:"key_tab_secret_id,omitempty"`
}

type LdapIdmapInitParameters struct {

	// (Updatable) The maximum amount of time the mount target is allowed to use a cached entry.
	CacheLifetimeSeconds *float64 `json:"cacheLifetimeSeconds,omitempty" tf:"cache_lifetime_seconds,omitempty"`

	// (Updatable) The amount of time that the mount target should allow an entry to persist in its cache before attempting to refresh the entry.
	CacheRefreshIntervalSeconds *float64 `json:"cacheRefreshIntervalSeconds,omitempty" tf:"cache_refresh_interval_seconds,omitempty"`

	// (Updatable) All LDAP searches are recursive starting at this group.  Example: CN=Group,DC=domain,DC=com
	GroupSearchBase *string `json:"groupSearchBase,omitempty" tf:"group_search_base,omitempty"`

	// (Updatable) The amount of time that a mount target will maintain information that a user is not found in the ID mapping configuration.
	NegativeCacheLifetimeSeconds *float64 `json:"negativeCacheLifetimeSeconds,omitempty" tf:"negative_cache_lifetime_seconds,omitempty"`

	// (Updatable) The OCID of the first connector to use to communicate with the LDAP server.
	OutboundConnector1Id *string `json:"outboundConnector1Id,omitempty" tf:"outbound_connector1id,omitempty"`

	// (Updatable) The OCID of the second connector to use to communicate with the LDAP server.
	OutboundConnector2Id *string `json:"outboundConnector2Id,omitempty" tf:"outbound_connector2id,omitempty"`

	// (Updatable) Schema type of the LDAP account.
	SchemaType *string `json:"schemaType,omitempty" tf:"schema_type,omitempty"`

	// (Updatable) All LDAP searches are recursive starting at this user.  Example: CN=User,DC=domain,DC=com
	UserSearchBase *string `json:"userSearchBase,omitempty" tf:"user_search_base,omitempty"`
}

type LdapIdmapObservation struct {

	// (Updatable) The maximum amount of time the mount target is allowed to use a cached entry.
	CacheLifetimeSeconds *float64 `json:"cacheLifetimeSeconds,omitempty" tf:"cache_lifetime_seconds,omitempty"`

	// (Updatable) The amount of time that the mount target should allow an entry to persist in its cache before attempting to refresh the entry.
	CacheRefreshIntervalSeconds *float64 `json:"cacheRefreshIntervalSeconds,omitempty" tf:"cache_refresh_interval_seconds,omitempty"`

	// (Updatable) All LDAP searches are recursive starting at this group.  Example: CN=Group,DC=domain,DC=com
	GroupSearchBase *string `json:"groupSearchBase,omitempty" tf:"group_search_base,omitempty"`

	// (Updatable) The amount of time that a mount target will maintain information that a user is not found in the ID mapping configuration.
	NegativeCacheLifetimeSeconds *float64 `json:"negativeCacheLifetimeSeconds,omitempty" tf:"negative_cache_lifetime_seconds,omitempty"`

	// (Updatable) The OCID of the first connector to use to communicate with the LDAP server.
	OutboundConnector1Id *string `json:"outboundConnector1Id,omitempty" tf:"outbound_connector1id,omitempty"`

	// (Updatable) The OCID of the second connector to use to communicate with the LDAP server.
	OutboundConnector2Id *string `json:"outboundConnector2Id,omitempty" tf:"outbound_connector2id,omitempty"`

	// (Updatable) Schema type of the LDAP account.
	SchemaType *string `json:"schemaType,omitempty" tf:"schema_type,omitempty"`

	// (Updatable) All LDAP searches are recursive starting at this user.  Example: CN=User,DC=domain,DC=com
	UserSearchBase *string `json:"userSearchBase,omitempty" tf:"user_search_base,omitempty"`
}

type LdapIdmapParameters struct {

	// (Updatable) The maximum amount of time the mount target is allowed to use a cached entry.
	// +kubebuilder:validation:Optional
	CacheLifetimeSeconds *float64 `json:"cacheLifetimeSeconds,omitempty" tf:"cache_lifetime_seconds,omitempty"`

	// (Updatable) The amount of time that the mount target should allow an entry to persist in its cache before attempting to refresh the entry.
	// +kubebuilder:validation:Optional
	CacheRefreshIntervalSeconds *float64 `json:"cacheRefreshIntervalSeconds,omitempty" tf:"cache_refresh_interval_seconds,omitempty"`

	// (Updatable) All LDAP searches are recursive starting at this group.  Example: CN=Group,DC=domain,DC=com
	// +kubebuilder:validation:Optional
	GroupSearchBase *string `json:"groupSearchBase,omitempty" tf:"group_search_base,omitempty"`

	// (Updatable) The amount of time that a mount target will maintain information that a user is not found in the ID mapping configuration.
	// +kubebuilder:validation:Optional
	NegativeCacheLifetimeSeconds *float64 `json:"negativeCacheLifetimeSeconds,omitempty" tf:"negative_cache_lifetime_seconds,omitempty"`

	// (Updatable) The OCID of the first connector to use to communicate with the LDAP server.
	// +kubebuilder:validation:Optional
	OutboundConnector1Id *string `json:"outboundConnector1Id,omitempty" tf:"outbound_connector1id,omitempty"`

	// (Updatable) The OCID of the second connector to use to communicate with the LDAP server.
	// +kubebuilder:validation:Optional
	OutboundConnector2Id *string `json:"outboundConnector2Id,omitempty" tf:"outbound_connector2id,omitempty"`

	// (Updatable) Schema type of the LDAP account.
	// +kubebuilder:validation:Optional
	SchemaType *string `json:"schemaType,omitempty" tf:"schema_type,omitempty"`

	// (Updatable) All LDAP searches are recursive starting at this user.  Example: CN=User,DC=domain,DC=com
	// +kubebuilder:validation:Optional
	UserSearchBase *string `json:"userSearchBase,omitempty" tf:"user_search_base,omitempty"`
}

type StorageMountTargetInitParameters struct {

	// The availability domain in which to create the mount target.  Example: Uocm:PHX-AD-1
	AvailabilityDomain *string `json:"availabilityDomain,omitempty" tf:"availability_domain,omitempty"`

	// (Updatable) The OCID of the compartment in which to create the mount target.
	// +crossplane:generate:reference:type=github.com/oracle/provider-oci/apis/identity/v1alpha1.Compartment
	CompartmentID *string `json:"compartmentId,omitempty" tf:"compartment_id,omitempty"`

	// Reference to a Compartment in identity to populate compartmentId.
	// +kubebuilder:validation:Optional
	CompartmentIDRef *v1.Reference `json:"compartmentIdRef,omitempty" tf:"-"`

	// Selector for a Compartment in identity to populate compartmentId.
	// +kubebuilder:validation:Optional
	CompartmentIDSelector *v1.Selector `json:"compartmentIdSelector,omitempty" tf:"-"`

	// (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see Resource Tags. Example: {"Operations.CostCenter": "42"}
	// +mapType=granular
	DefinedTags map[string]*string `json:"definedTags,omitempty" tf:"defined_tags,omitempty"`

	// (Updatable) A user-friendly name. It does not have to be unique, and it is changeable. Avoid entering confidential information.  Example: My mount target
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// (Updatable) Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see Resource Tags. Example: {"Department": "Finance"}
	// +mapType=granular
	FreeformTags map[string]*string `json:"freeformTags,omitempty" tf:"freeform_tags,omitempty"`

	// The hostname for the mount target's IP address, used for DNS resolution. The value is the hostname portion of the private IP address's fully qualified domain name (FQDN). For example, files-1 in the FQDN files-1.subnet123.vcn1.oraclevcn.com. Must be unique across all VNICs in the subnet and comply with RFC 952 and RFC 1123.
	HostnameLabel *string `json:"hostnameLabel,omitempty" tf:"hostname_label,omitempty"`

	// A private IP address of your choice. Must be an available IP address within the subnet's CIDR. If you don't specify a value, Oracle automatically assigns a private IP address from the subnet.  Example: 10.0.3.3
	IPAddress *string `json:"ipAddress,omitempty" tf:"ip_address,omitempty"`

	// (Updatable) The method used to map a Unix UID to secondary groups, if any.
	IdmapType *string `json:"idmapType,omitempty" tf:"idmap_type,omitempty"`

	// (Updatable) Whether to override locks (if any exist).
	IsLockOverride *bool `json:"isLockOverride,omitempty" tf:"is_lock_override,omitempty"`

	// (Updatable) Kerberos details needed to create configuration.
	Kerberos []KerberosInitParameters `json:"kerberos,omitempty" tf:"kerberos,omitempty"`

	// (Updatable) Mount target details about the LDAP ID mapping configuration.
	LdapIdmap []LdapIdmapInitParameters `json:"ldapIdmap,omitempty" tf:"ldap_idmap,omitempty"`

	// Locks associated with this resource.
	Locks []StorageMountTargetLocksInitParameters `json:"locks,omitempty" tf:"locks,omitempty"`

	// (Updatable) A list of Network Security Group OCIDs associated with this mount target. A maximum of 5 is allowed. Setting this to an empty array after the list is created removes the mount target from all NSGs. For more information about NSGs, see Security Rules.
	// +listType=set
	NsgIds []*string `json:"nsgIds,omitempty" tf:"nsg_ids,omitempty"`

	// (Updatable) Throughput for mount target in Gbps. Currently only 1 Gbps of requestedThroughput is supported during create MountTarget. Available shapes and corresponding throughput are listed at Mount Target Performance.
	RequestedThroughput *string `json:"requestedThroughput,omitempty" tf:"requested_throughput,omitempty"`

	// The OCID of the subnet in which to create the mount target.
	// +crossplane:generate:reference:type=github.com/oracle/provider-oci/apis/core/v1alpha1.Subnet
	SubnetID *string `json:"subnetId,omitempty" tf:"subnet_id,omitempty"`

	// Reference to a Subnet in core to populate subnetId.
	// +kubebuilder:validation:Optional
	SubnetIDRef *v1.Reference `json:"subnetIdRef,omitempty" tf:"-"`

	// Selector for a Subnet in core to populate subnetId.
	// +kubebuilder:validation:Optional
	SubnetIDSelector *v1.Selector `json:"subnetIdSelector,omitempty" tf:"-"`
}

type StorageMountTargetLocksInitParameters struct {

	// A message added by the creator of the lock. This is typically used to give an indication of why the resource is locked.
	Message *string `json:"message,omitempty" tf:"message,omitempty"`

	// The ID of the resource that is locking this resource. Indicates that deleting this resource will remove the lock.
	RelatedResourceID *string `json:"relatedResourceId,omitempty" tf:"related_resource_id,omitempty"`

	// When the lock was created.
	TimeCreated *string `json:"timeCreated,omitempty" tf:"time_created,omitempty"`

	// Type of the lock.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type StorageMountTargetLocksObservation struct {

	// A message added by the creator of the lock. This is typically used to give an indication of why the resource is locked.
	Message *string `json:"message,omitempty" tf:"message,omitempty"`

	// The ID of the resource that is locking this resource. Indicates that deleting this resource will remove the lock.
	RelatedResourceID *string `json:"relatedResourceId,omitempty" tf:"related_resource_id,omitempty"`

	// When the lock was created.
	TimeCreated *string `json:"timeCreated,omitempty" tf:"time_created,omitempty"`

	// Type of the lock.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type StorageMountTargetLocksParameters struct {

	// A message added by the creator of the lock. This is typically used to give an indication of why the resource is locked.
	// +kubebuilder:validation:Optional
	Message *string `json:"message,omitempty" tf:"message,omitempty"`

	// The ID of the resource that is locking this resource. Indicates that deleting this resource will remove the lock.
	// +kubebuilder:validation:Optional
	RelatedResourceID *string `json:"relatedResourceId,omitempty" tf:"related_resource_id,omitempty"`

	// When the lock was created.
	// +kubebuilder:validation:Optional
	TimeCreated *string `json:"timeCreated,omitempty" tf:"time_created,omitempty"`

	// Type of the lock.
	// +kubebuilder:validation:Optional
	Type *string `json:"type" tf:"type,omitempty"`
}

type StorageMountTargetObservation struct {

	// The availability domain in which to create the mount target.  Example: Uocm:PHX-AD-1
	AvailabilityDomain *string `json:"availabilityDomain,omitempty" tf:"availability_domain,omitempty"`

	// (Updatable) The OCID of the compartment in which to create the mount target.
	CompartmentID *string `json:"compartmentId,omitempty" tf:"compartment_id,omitempty"`

	// (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see Resource Tags. Example: {"Operations.CostCenter": "42"}
	// +mapType=granular
	DefinedTags map[string]*string `json:"definedTags,omitempty" tf:"defined_tags,omitempty"`

	// (Updatable) A user-friendly name. It does not have to be unique, and it is changeable. Avoid entering confidential information.  Example: My mount target
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// The OCID of the associated export set. Controls what file systems will be exported through Network File System (NFS) protocol on this mount target.
	ExportSetID *string `json:"exportSetId,omitempty" tf:"export_set_id,omitempty"`

	// (Updatable) Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see Resource Tags. Example: {"Department": "Finance"}
	// +mapType=granular
	FreeformTags map[string]*string `json:"freeformTags,omitempty" tf:"freeform_tags,omitempty"`

	// The hostname for the mount target's IP address, used for DNS resolution. The value is the hostname portion of the private IP address's fully qualified domain name (FQDN). For example, files-1 in the FQDN files-1.subnet123.vcn1.oraclevcn.com. Must be unique across all VNICs in the subnet and comply with RFC 952 and RFC 1123.
	HostnameLabel *string `json:"hostnameLabel,omitempty" tf:"hostname_label,omitempty"`

	// The OCID of the mount target.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// A private IP address of your choice. Must be an available IP address within the subnet's CIDR. If you don't specify a value, Oracle automatically assigns a private IP address from the subnet.  Example: 10.0.3.3
	IPAddress *string `json:"ipAddress,omitempty" tf:"ip_address,omitempty"`

	// (Updatable) The method used to map a Unix UID to secondary groups, if any.
	IdmapType *string `json:"idmapType,omitempty" tf:"idmap_type,omitempty"`

	// (Updatable) Whether to override locks (if any exist).
	IsLockOverride *bool `json:"isLockOverride,omitempty" tf:"is_lock_override,omitempty"`

	// (Updatable) Kerberos details needed to create configuration.
	Kerberos []KerberosObservation `json:"kerberos,omitempty" tf:"kerberos,omitempty"`

	// (Updatable) Mount target details about the LDAP ID mapping configuration.
	LdapIdmap []LdapIdmapObservation `json:"ldapIdmap,omitempty" tf:"ldap_idmap,omitempty"`

	// Additional information about the current 'lifecycleState'.
	LifecycleDetails *string `json:"lifecycleDetails,omitempty" tf:"lifecycle_details,omitempty"`

	// Locks associated with this resource.
	Locks []StorageMountTargetLocksObservation `json:"locks,omitempty" tf:"locks,omitempty"`

	// (Updatable) A list of Network Security Group OCIDs associated with this mount target. A maximum of 5 is allowed. Setting this to an empty array after the list is created removes the mount target from all NSGs. For more information about NSGs, see Security Rules.
	// +listType=set
	NsgIds []*string `json:"nsgIds,omitempty" tf:"nsg_ids,omitempty"`

	// Current billed throughput for mount target in Gbps. This corresponds to shape of mount target. Available shapes and corresponding throughput are listed at Mount Target Performance.
	ObservedThroughput *string `json:"observedThroughput,omitempty" tf:"observed_throughput,omitempty"`

	// The OCIDs of the private IP addresses associated with this mount target.
	PrivateIPIds []*string `json:"privateIpIds,omitempty" tf:"private_ip_ids,omitempty"`

	// (Updatable) Throughput for mount target in Gbps. Currently only 1 Gbps of requestedThroughput is supported during create MountTarget. Available shapes and corresponding throughput are listed at Mount Target Performance.
	RequestedThroughput *string `json:"requestedThroughput,omitempty" tf:"requested_throughput,omitempty"`

	ReservedStorageCapacity *string `json:"reservedStorageCapacity,omitempty" tf:"reserved_storage_capacity,omitempty"`

	// The current state of the mount target.
	State *string `json:"state,omitempty" tf:"state,omitempty"`

	// The OCID of the subnet in which to create the mount target.
	SubnetID *string `json:"subnetId,omitempty" tf:"subnet_id,omitempty"`

	// System tags for this resource. System tags are applied to resources by internal Oracle Cloud Infrastructure services.
	// +mapType=granular
	SystemTags map[string]*string `json:"systemTags,omitempty" tf:"system_tags,omitempty"`

	// The date and time the mount target current billing cycle will end, expressed in  RFC 3339 timestamp format. Once a cycle ends, it is updated  automatically to next timestamp which is after 30 days.  Example: 2016-08-25T21:10:29.600Z
	TimeBillingCycleEnd *string `json:"timeBillingCycleEnd,omitempty" tf:"time_billing_cycle_end,omitempty"`

	// When the lock was created.
	TimeCreated *string `json:"timeCreated,omitempty" tf:"time_created,omitempty"`
}

type StorageMountTargetParameters struct {

	// The availability domain in which to create the mount target.  Example: Uocm:PHX-AD-1
	// +kubebuilder:validation:Optional
	AvailabilityDomain *string `json:"availabilityDomain,omitempty" tf:"availability_domain,omitempty"`

	// (Updatable) The OCID of the compartment in which to create the mount target.
	// +crossplane:generate:reference:type=github.com/oracle/provider-oci/apis/identity/v1alpha1.Compartment
	// +kubebuilder:validation:Optional
	CompartmentID *string `json:"compartmentId,omitempty" tf:"compartment_id,omitempty"`

	// Reference to a Compartment in identity to populate compartmentId.
	// +kubebuilder:validation:Optional
	CompartmentIDRef *v1.Reference `json:"compartmentIdRef,omitempty" tf:"-"`

	// Selector for a Compartment in identity to populate compartmentId.
	// +kubebuilder:validation:Optional
	CompartmentIDSelector *v1.Selector `json:"compartmentIdSelector,omitempty" tf:"-"`

	// (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see Resource Tags. Example: {"Operations.CostCenter": "42"}
	// +kubebuilder:validation:Optional
	// +mapType=granular
	DefinedTags map[string]*string `json:"definedTags,omitempty" tf:"defined_tags,omitempty"`

	// (Updatable) A user-friendly name. It does not have to be unique, and it is changeable. Avoid entering confidential information.  Example: My mount target
	// +kubebuilder:validation:Optional
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// (Updatable) Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see Resource Tags. Example: {"Department": "Finance"}
	// +kubebuilder:validation:Optional
	// +mapType=granular
	FreeformTags map[string]*string `json:"freeformTags,omitempty" tf:"freeform_tags,omitempty"`

	// The hostname for the mount target's IP address, used for DNS resolution. The value is the hostname portion of the private IP address's fully qualified domain name (FQDN). For example, files-1 in the FQDN files-1.subnet123.vcn1.oraclevcn.com. Must be unique across all VNICs in the subnet and comply with RFC 952 and RFC 1123.
	// +kubebuilder:validation:Optional
	HostnameLabel *string `json:"hostnameLabel,omitempty" tf:"hostname_label,omitempty"`

	// A private IP address of your choice. Must be an available IP address within the subnet's CIDR. If you don't specify a value, Oracle automatically assigns a private IP address from the subnet.  Example: 10.0.3.3
	// +kubebuilder:validation:Optional
	IPAddress *string `json:"ipAddress,omitempty" tf:"ip_address,omitempty"`

	// (Updatable) The method used to map a Unix UID to secondary groups, if any.
	// +kubebuilder:validation:Optional
	IdmapType *string `json:"idmapType,omitempty" tf:"idmap_type,omitempty"`

	// (Updatable) Whether to override locks (if any exist).
	// +kubebuilder:validation:Optional
	IsLockOverride *bool `json:"isLockOverride,omitempty" tf:"is_lock_override,omitempty"`

	// (Updatable) Kerberos details needed to create configuration.
	// +kubebuilder:validation:Optional
	Kerberos []KerberosParameters `json:"kerberos,omitempty" tf:"kerberos,omitempty"`

	// (Updatable) Mount target details about the LDAP ID mapping configuration.
	// +kubebuilder:validation:Optional
	LdapIdmap []LdapIdmapParameters `json:"ldapIdmap,omitempty" tf:"ldap_idmap,omitempty"`

	// Locks associated with this resource.
	// +kubebuilder:validation:Optional
	Locks []StorageMountTargetLocksParameters `json:"locks,omitempty" tf:"locks,omitempty"`

	// (Updatable) A list of Network Security Group OCIDs associated with this mount target. A maximum of 5 is allowed. Setting this to an empty array after the list is created removes the mount target from all NSGs. For more information about NSGs, see Security Rules.
	// +kubebuilder:validation:Optional
	// +listType=set
	NsgIds []*string `json:"nsgIds,omitempty" tf:"nsg_ids,omitempty"`

	// (Updatable) Throughput for mount target in Gbps. Currently only 1 Gbps of requestedThroughput is supported during create MountTarget. Available shapes and corresponding throughput are listed at Mount Target Performance.
	// +kubebuilder:validation:Optional
	RequestedThroughput *string `json:"requestedThroughput,omitempty" tf:"requested_throughput,omitempty"`

	// The OCID of the subnet in which to create the mount target.
	// +crossplane:generate:reference:type=github.com/oracle/provider-oci/apis/core/v1alpha1.Subnet
	// +kubebuilder:validation:Optional
	SubnetID *string `json:"subnetId,omitempty" tf:"subnet_id,omitempty"`

	// Reference to a Subnet in core to populate subnetId.
	// +kubebuilder:validation:Optional
	SubnetIDRef *v1.Reference `json:"subnetIdRef,omitempty" tf:"-"`

	// Selector for a Subnet in core to populate subnetId.
	// +kubebuilder:validation:Optional
	SubnetIDSelector *v1.Selector `json:"subnetIdSelector,omitempty" tf:"-"`
}

// StorageMountTargetSpec defines the desired state of StorageMountTarget
type StorageMountTargetSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     StorageMountTargetParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider StorageMountTargetInitParameters `json:"initProvider,omitempty"`
}

// StorageMountTargetStatus defines the observed state of StorageMountTarget.
type StorageMountTargetStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        StorageMountTargetObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// StorageMountTarget is the Schema for the StorageMountTargets API. Provides the Mount Target resource in Oracle Cloud Infrastructure File Storage service
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,oci}
type StorageMountTarget struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.availabilityDomain) || (has(self.initProvider) && has(self.initProvider.availabilityDomain))",message="spec.forProvider.availabilityDomain is a required parameter"
	Spec   StorageMountTargetSpec   `json:"spec"`
	Status StorageMountTargetStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// StorageMountTargetList contains a list of StorageMountTargets
type StorageMountTargetList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []StorageMountTarget `json:"items"`
}

// Repository type metadata.
var (
	StorageMountTarget_Kind             = "StorageMountTarget"
	StorageMountTarget_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: StorageMountTarget_Kind}.String()
	StorageMountTarget_KindAPIVersion   = StorageMountTarget_Kind + "." + CRDGroupVersion.String()
	StorageMountTarget_GroupVersionKind = CRDGroupVersion.WithKind(StorageMountTarget_Kind)
)

func init() {
	SchemeBuilder.Register(&StorageMountTarget{}, &StorageMountTargetList{})
}
