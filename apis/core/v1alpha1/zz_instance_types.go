/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AgentConfigObservation struct {
}

type AgentConfigParameters struct {

	// +kubebuilder:validation:Optional
	AreAllPluginsDisabled *bool `json:"areAllPluginsDisabled,omitempty" tf:"are_all_plugins_disabled,omitempty"`

	// +kubebuilder:validation:Optional
	IsManagementDisabled *bool `json:"isManagementDisabled,omitempty" tf:"is_management_disabled,omitempty"`

	// +kubebuilder:validation:Optional
	IsMonitoringDisabled *bool `json:"isMonitoringDisabled,omitempty" tf:"is_monitoring_disabled,omitempty"`

	// +kubebuilder:validation:Optional
	PluginsConfig []PluginsConfigParameters `json:"pluginsConfig,omitempty" tf:"plugins_config,omitempty"`
}

type AvailabilityConfigObservation struct {
}

type AvailabilityConfigParameters struct {

	// +kubebuilder:validation:Optional
	IsLiveMigrationPreferred *bool `json:"isLiveMigrationPreferred,omitempty" tf:"is_live_migration_preferred,omitempty"`

	// +kubebuilder:validation:Optional
	RecoveryAction *string `json:"recoveryAction,omitempty" tf:"recovery_action,omitempty"`
}

type CreateVnicDetailsObservation struct {
}

type CreateVnicDetailsParameters struct {

	// +kubebuilder:validation:Optional
	AssignPrivateDNSRecord *bool `json:"assignPrivateDnsRecord,omitempty" tf:"assign_private_dns_record,omitempty"`

	// +kubebuilder:validation:Optional
	AssignPublicIP *string `json:"assignPublicIp,omitempty" tf:"assign_public_ip,omitempty"`

	// +kubebuilder:validation:Optional
	DefinedTags map[string]*string `json:"definedTags,omitempty" tf:"defined_tags,omitempty"`

	// +kubebuilder:validation:Optional
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// +kubebuilder:validation:Optional
	FreeformTags map[string]*string `json:"freeformTags,omitempty" tf:"freeform_tags,omitempty"`

	// +kubebuilder:validation:Optional
	HostnameLabel *string `json:"hostnameLabel,omitempty" tf:"hostname_label,omitempty"`

	// +crossplane:generate:reference:type=NetworkSecurityGroup
	// +kubebuilder:validation:Optional
	NsgIds []*string `json:"nsgIds,omitempty" tf:"nsg_ids,omitempty"`

	// +kubebuilder:validation:Optional
	NsgIdsRefs []v1.Reference `json:"nsgIdsRefs,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	NsgIdsSelector *v1.Selector `json:"nsgIdsSelector,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	PrivateIP *string `json:"privateIp,omitempty" tf:"private_ip,omitempty"`

	// +kubebuilder:validation:Optional
	SkipSourceDestCheck *bool `json:"skipSourceDestCheck,omitempty" tf:"skip_source_dest_check,omitempty"`

	// +crossplane:generate:reference:type=Subnet
	// +kubebuilder:validation:Optional
	SubnetID *string `json:"subnetId,omitempty" tf:"subnet_id,omitempty"`

	// +kubebuilder:validation:Optional
	SubnetIDRef *v1.Reference `json:"subnetIdRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	SubnetIDSelector *v1.Selector `json:"subnetIdSelector,omitempty" tf:"-"`

	// +crossplane:generate:reference:type=Vlan
	// +kubebuilder:validation:Optional
	VlanID *string `json:"vlanId,omitempty" tf:"vlan_id,omitempty"`

	// +kubebuilder:validation:Optional
	VlanIDRef *v1.Reference `json:"vlanIdRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	VlanIDSelector *v1.Selector `json:"vlanIdSelector,omitempty" tf:"-"`
}

type InstanceLaunchOptionsObservation struct {
}

type InstanceLaunchOptionsParameters struct {

	// +kubebuilder:validation:Optional
	BootVolumeType *string `json:"bootVolumeType,omitempty" tf:"boot_volume_type,omitempty"`

	// +kubebuilder:validation:Optional
	Firmware *string `json:"firmware,omitempty" tf:"firmware,omitempty"`

	// +kubebuilder:validation:Optional
	IsConsistentVolumeNamingEnabled *bool `json:"isConsistentVolumeNamingEnabled,omitempty" tf:"is_consistent_volume_naming_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	IsPvEncryptionInTransitEnabled *bool `json:"isPvEncryptionInTransitEnabled,omitempty" tf:"is_pv_encryption_in_transit_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	NetworkType *string `json:"networkType,omitempty" tf:"network_type,omitempty"`

	// +kubebuilder:validation:Optional
	RemoteDataVolumeType *string `json:"remoteDataVolumeType,omitempty" tf:"remote_data_volume_type,omitempty"`
}

type InstanceObservation struct {
	BootVolumeID *string `json:"bootVolumeId,omitempty" tf:"boot_volume_id,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	LaunchMode *string `json:"launchMode,omitempty" tf:"launch_mode,omitempty"`

	PrivateIP *string `json:"privateIp,omitempty" tf:"private_ip,omitempty"`

	PublicIP *string `json:"publicIp,omitempty" tf:"public_ip,omitempty"`

	Region *string `json:"region,omitempty" tf:"region,omitempty"`

	SystemTags map[string]*string `json:"systemTags,omitempty" tf:"system_tags,omitempty"`

	TimeCreated *string `json:"timeCreated,omitempty" tf:"time_created,omitempty"`

	TimeMaintenanceRebootDue *string `json:"timeMaintenanceRebootDue,omitempty" tf:"time_maintenance_reboot_due,omitempty"`
}

type InstanceOptionsObservation struct {
}

type InstanceOptionsParameters struct {

	// +kubebuilder:validation:Optional
	AreLegacyImdsEndpointsDisabled *bool `json:"areLegacyImdsEndpointsDisabled,omitempty" tf:"are_legacy_imds_endpoints_disabled,omitempty"`
}

type InstanceParameters struct {

	// +kubebuilder:validation:Optional
	AgentConfig []AgentConfigParameters `json:"agentConfig,omitempty" tf:"agent_config,omitempty"`

	// +kubebuilder:validation:Optional
	Async *bool `json:"async,omitempty" tf:"async,omitempty"`

	// +kubebuilder:validation:Optional
	AvailabilityConfig []AvailabilityConfigParameters `json:"availabilityConfig,omitempty" tf:"availability_config,omitempty"`

	// +kubebuilder:validation:Required
	AvailabilityDomain *string `json:"availabilityDomain" tf:"availability_domain,omitempty"`

	// +kubebuilder:validation:Optional
	CapacityReservationID *string `json:"capacityReservationId,omitempty" tf:"capacity_reservation_id,omitempty"`

	// +crossplane:generate:reference:type=github.com/crossplane-contrib/provider-jet-oci/apis/identity/v1alpha1.Compartment
	// +kubebuilder:validation:Optional
	CompartmentID *string `json:"compartmentId,omitempty" tf:"compartment_id,omitempty"`

	// +kubebuilder:validation:Optional
	CompartmentIDRef *v1.Reference `json:"compartmentIdRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	CompartmentIDSelector *v1.Selector `json:"compartmentIdSelector,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	CreateVnicDetails []CreateVnicDetailsParameters `json:"createVnicDetails,omitempty" tf:"create_vnic_details,omitempty"`

	// +crossplane:generate:reference:type=DedicatedVMHost
	// +kubebuilder:validation:Optional
	DedicatedVMHostID *string `json:"dedicatedVmHostId,omitempty" tf:"dedicated_vm_host_id,omitempty"`

	// +kubebuilder:validation:Optional
	DedicatedVMHostIDRef *v1.Reference `json:"dedicatedVmHostIdRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	DedicatedVMHostIDSelector *v1.Selector `json:"dedicatedVmHostIdSelector,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	DefinedTags map[string]*string `json:"definedTags,omitempty" tf:"defined_tags,omitempty"`

	// +kubebuilder:validation:Optional
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// +kubebuilder:validation:Optional
	ExtendedMetadata map[string]*string `json:"extendedMetadata,omitempty" tf:"extended_metadata,omitempty"`

	// +kubebuilder:validation:Optional
	FaultDomain *string `json:"faultDomain,omitempty" tf:"fault_domain,omitempty"`

	// +kubebuilder:validation:Optional
	FreeformTags map[string]*string `json:"freeformTags,omitempty" tf:"freeform_tags,omitempty"`

	// +kubebuilder:validation:Optional
	HostnameLabel *string `json:"hostnameLabel,omitempty" tf:"hostname_label,omitempty"`

	// +kubebuilder:validation:Optional
	Image *string `json:"image,omitempty" tf:"image,omitempty"`

	// +kubebuilder:validation:Optional
	InstanceOptions []InstanceOptionsParameters `json:"instanceOptions,omitempty" tf:"instance_options,omitempty"`

	// +kubebuilder:validation:Optional
	IpxeScript *string `json:"ipxeScript,omitempty" tf:"ipxe_script,omitempty"`

	// +kubebuilder:validation:Optional
	IsPvEncryptionInTransitEnabled *bool `json:"isPvEncryptionInTransitEnabled,omitempty" tf:"is_pv_encryption_in_transit_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	LaunchOptions []InstanceLaunchOptionsParameters `json:"launchOptions,omitempty" tf:"launch_options,omitempty"`

	// +kubebuilder:validation:Optional
	Metadata map[string]*string `json:"metadata,omitempty" tf:"metadata,omitempty"`

	// +kubebuilder:validation:Optional
	PlatformConfig []PlatformConfigParameters `json:"platformConfig,omitempty" tf:"platform_config,omitempty"`

	// +kubebuilder:validation:Optional
	PreemptibleInstanceConfig []PreemptibleInstanceConfigParameters `json:"preemptibleInstanceConfig,omitempty" tf:"preemptible_instance_config,omitempty"`

	// +kubebuilder:validation:Optional
	PreserveBootVolume *bool `json:"preserveBootVolume,omitempty" tf:"preserve_boot_volume,omitempty"`

	// +kubebuilder:validation:Required
	Shape *string `json:"shape" tf:"shape,omitempty"`

	// +kubebuilder:validation:Optional
	ShapeConfig []ShapeConfigParameters `json:"shapeConfig,omitempty" tf:"shape_config,omitempty"`

	// +kubebuilder:validation:Optional
	SourceDetails []SourceDetailsParameters `json:"sourceDetails,omitempty" tf:"source_details,omitempty"`

	// +kubebuilder:validation:Optional
	State *string `json:"state,omitempty" tf:"state,omitempty"`

	// +kubebuilder:validation:Optional
	SubnetID *string `json:"subnetId,omitempty" tf:"subnet_id,omitempty"`
}

type PlatformConfigObservation struct {
}

type PlatformConfigParameters struct {

	// +kubebuilder:validation:Optional
	AreVirtualInstructionsEnabled *bool `json:"areVirtualInstructionsEnabled,omitempty" tf:"are_virtual_instructions_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	IsAccessControlServiceEnabled *bool `json:"isAccessControlServiceEnabled,omitempty" tf:"is_access_control_service_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	IsInputOutputMemoryManagementUnitEnabled *bool `json:"isInputOutputMemoryManagementUnitEnabled,omitempty" tf:"is_input_output_memory_management_unit_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	IsMeasuredBootEnabled *bool `json:"isMeasuredBootEnabled,omitempty" tf:"is_measured_boot_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	IsSecureBootEnabled *bool `json:"isSecureBootEnabled,omitempty" tf:"is_secure_boot_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	IsSymmetricMultiThreadingEnabled *bool `json:"isSymmetricMultiThreadingEnabled,omitempty" tf:"is_symmetric_multi_threading_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	IsTrustedPlatformModuleEnabled *bool `json:"isTrustedPlatformModuleEnabled,omitempty" tf:"is_trusted_platform_module_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	NumaNodesPerSocket *string `json:"numaNodesPerSocket,omitempty" tf:"numa_nodes_per_socket,omitempty"`

	// +kubebuilder:validation:Optional
	PercentageOfCoresEnabled *float64 `json:"percentageOfCoresEnabled,omitempty" tf:"percentage_of_cores_enabled,omitempty"`

	// +kubebuilder:validation:Required
	Type *string `json:"type" tf:"type,omitempty"`
}

type PluginsConfigObservation struct {
}

type PluginsConfigParameters struct {

	// +kubebuilder:validation:Required
	DesiredState *string `json:"desiredState" tf:"desired_state,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`
}

type PreemptibleInstanceConfigObservation struct {
}

type PreemptibleInstanceConfigParameters struct {

	// +kubebuilder:validation:Required
	PreemptionAction []PreemptionActionParameters `json:"preemptionAction" tf:"preemption_action,omitempty"`
}

type PreemptionActionObservation struct {
}

type PreemptionActionParameters struct {

	// +kubebuilder:validation:Optional
	PreserveBootVolume *bool `json:"preserveBootVolume,omitempty" tf:"preserve_boot_volume,omitempty"`

	// +kubebuilder:validation:Required
	Type *string `json:"type" tf:"type,omitempty"`
}

type ShapeConfigObservation struct {
	GpuDescription *string `json:"gpuDescription,omitempty" tf:"gpu_description,omitempty"`

	Gpus *float64 `json:"gpus,omitempty" tf:"gpus,omitempty"`

	LocalDiskDescription *string `json:"localDiskDescription,omitempty" tf:"local_disk_description,omitempty"`

	LocalDisks *float64 `json:"localDisks,omitempty" tf:"local_disks,omitempty"`

	LocalDisksTotalSizeInGbs *float64 `json:"localDisksTotalSizeInGbs,omitempty" tf:"local_disks_total_size_in_gbs,omitempty"`

	MaxVnicAttachments *float64 `json:"maxVnicAttachments,omitempty" tf:"max_vnic_attachments,omitempty"`

	NetworkingBandwidthInGbps *float64 `json:"networkingBandwidthInGbps,omitempty" tf:"networking_bandwidth_in_gbps,omitempty"`

	ProcessorDescription *string `json:"processorDescription,omitempty" tf:"processor_description,omitempty"`
}

type ShapeConfigParameters struct {

	// +kubebuilder:validation:Optional
	BaselineOcpuUtilization *string `json:"baselineOcpuUtilization,omitempty" tf:"baseline_ocpu_utilization,omitempty"`

	// +kubebuilder:validation:Optional
	MemoryInGbs *float64 `json:"memoryInGbs,omitempty" tf:"memory_in_gbs,omitempty"`

	// +kubebuilder:validation:Optional
	Nvmes *float64 `json:"nvmes,omitempty" tf:"nvmes,omitempty"`

	// +kubebuilder:validation:Optional
	Ocpus *float64 `json:"ocpus,omitempty" tf:"ocpus,omitempty"`
}

type SourceDetailsObservation struct {
}

type SourceDetailsParameters struct {

	// +kubebuilder:validation:Optional
	BootVolumeSizeInGbs *string `json:"bootVolumeSizeInGbs,omitempty" tf:"boot_volume_size_in_gbs,omitempty"`

	// +kubebuilder:validation:Optional
	BootVolumeVpusPerGb *string `json:"bootVolumeVpusPerGb,omitempty" tf:"boot_volume_vpus_per_gb,omitempty"`

	// +kubebuilder:validation:Optional
	KMSKeyID *string `json:"kmsKeyId,omitempty" tf:"kms_key_id,omitempty"`

	// +crossplane:generate:reference:type=Image
	// +kubebuilder:validation:Optional
	SourceID *string `json:"sourceId,omitempty" tf:"source_id,omitempty"`

	// +kubebuilder:validation:Optional
	SourceIDRef *v1.Reference `json:"sourceIdRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	SourceIDSelector *v1.Selector `json:"sourceIdSelector,omitempty" tf:"-"`

	// +kubebuilder:validation:Required
	SourceType *string `json:"sourceType" tf:"source_type,omitempty"`
}

// InstanceSpec defines the desired state of Instance
type InstanceSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     InstanceParameters `json:"forProvider"`
}

// InstanceStatus defines the observed state of Instance.
type InstanceStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        InstanceObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Instance is the Schema for the Instances API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,ocijet}
type Instance struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              InstanceSpec   `json:"spec"`
	Status            InstanceStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// InstanceList contains a list of Instances
type InstanceList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Instance `json:"items"`
}

// Repository type metadata.
var (
	Instance_Kind             = "Instance"
	Instance_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Instance_Kind}.String()
	Instance_KindAPIVersion   = Instance_Kind + "." + CRDGroupVersion.String()
	Instance_GroupVersionKind = CRDGroupVersion.WithKind(Instance_Kind)
)

func init() {
	SchemeBuilder.Register(&Instance{}, &InstanceList{})
}
